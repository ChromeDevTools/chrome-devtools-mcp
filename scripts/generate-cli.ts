/**
 * @license
 * Copyright 2026 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'node:fs';
import path from 'node:path';
import {fileURLToPath} from 'node:url';

import {Client} from '@modelcontextprotocol/sdk/client/index.js';
import {StdioClientTransport} from '@modelcontextprotocol/sdk/client/stdio.js';

const OUTPUT_PATH = path.join(
  path.dirname(fileURLToPath(import.meta.url)),
  '../src/bin/cliDefinitions.ts',
);

async function fetchTools() {
  console.log('Connecting to chrome-devtools-mcp to fetch tools...');
  // Use the local build of the server
  const serverPath = path.join(
    path.dirname(fileURLToPath(import.meta.url)),
    '../build/src/index.js',
  );

  const transport = new StdioClientTransport({
    command: 'node',
    args: [serverPath],
    env: {...process.env, CHROME_DEVTOOLS_MCP_NO_USAGE_STATISTICS: 'true'},
  });

  const client = new Client(
    {
      name: 'chrome-devtools-cli-generator',
      version: '0.1.0',
    },
    {
      capabilities: {},
    },
  );

  await client.connect(transport);
  try {
    const toolsResponse = await client.listTools();
    const tools = toolsResponse.tools || [];
    console.log(`Fetched ${tools.length} tools`);
    return tools;
  } finally {
    await client.close();
  }
}

interface CliOption {
  name: string;
  type: string;
  description: string;
  required: boolean;
  default?: unknown;
  enum?: unknown[];
}

interface JsonSchema {
  type?: string | string[];
  description?: string;
  properties?: Record<string, JsonSchema>;
  required?: string[];
  default?: unknown;
  enum?: unknown[];
}

function schemaToCLIOptions(schema: JsonSchema): CliOption[] {
  if (!schema || !schema.properties) {
    return [];
  }
  const required = schema.required || [];
  const properties = schema.properties;
  return Object.entries(properties).map(([name, prop]) => {
    const isRequired = required.includes(name);
    let type = prop.type || 'string';
    if (Array.isArray(type)) {
      type = type[0];
    }
    const description = prop.description || '';

    return {
      name,
      type: type as string,
      description,
      required: isRequired,
      default: prop.default,
      enum: prop.enum,
    };
  });
}

async function generateCli() {
  const tools = await fetchTools();
  // Sort tools by name
  const sortedTools = tools.sort((a, b) => a.name.localeCompare(b.name));

  const commands: Record<
    string,
    {description: string; args: Record<string, CliOption>}
  > = {};

  for (const tool of sortedTools) {
    const options = schemaToCLIOptions(tool.inputSchema);
    const args: Record<string, CliOption> = {};
    for (const opt of options) {
      args[opt.name] = opt;
    }
    commands[tool.name] = {
      description: tool.description || '',
      args,
    };
  }

  const lines: string[] = [];
  lines.push(`/**
 * @license
 * Copyright 2026 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// NOTE: do not edit manually. Auto-generated by 'npm run cli:generate'.

export interface ArgDef {
  name: string;
  type: string;
  description: string;
  required: boolean;
  default?: string | number | boolean;
  enum?: ReadonlyArray<string | number>;
}
export type Commands = Record<
  string,
  {
    description: string;
    args: Record<string, ArgDef>
  }
>
export const commands: Commands = ${JSON.stringify(commands, null, 2)} as const;
`);

  fs.writeFileSync(OUTPUT_PATH, lines.join(''));
  console.log(`Generated CLI at ${OUTPUT_PATH}`);
}

generateCli().catch(err => {
  console.error('Error during generation:', err);
  process.exit(1);
});
